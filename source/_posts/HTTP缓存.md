---
title: HTTP缓存
date: 2019-08-22 16:42:17
tags:
---
1. 对于浏览器而言，过大的js或css文件都会造成加载时间过长的情况，所以这种情况下就需要缓存来减少加载量，控制缓存使用Cache-Control，在后台路径下设置response.setHeader('Cache-Control','max-age=(seconds)')，就可以设置在seconds秒内不重新加载相关文件，但是网页也可以选择勾选Disable cache来阻止缓存；
2. 首页禁止设置缓存，html文件一般不要设置缓存；
3. 一般来说网页的文件缓存时间都会设置得比较久（一般以年为单位），如果后面需要更新文件，再修改入口处，一般为html文件中的css和js路径，如在后面加上版本号如?v=1/2/3，或者加随机数；
4. 浏览器一般会自动权衡缓存的时间，浏览器的缓存空间是有限的，如果当前需要新的缓存空间，它就会清除旧的缓存文件腾出空间；
5. 以前的浏览器设置缓存是使用Expires，设置的格式如：'Sun, 04 Feb 2019 14:40:05 GM',但由于有新的方法Cache-Control，所以两者同时出现的话Cache-Control会覆盖Expires；Expires的缺陷在于，如果本机的本地时间出现错乱，它就会受到严重影响；
6. **替代缓存的方式：ETag：**
6.1 md5是一种摘要演算法，在git中输入**md5 文件名**就可以将文件的md5值运算出来，通过比较其值就可以判断是否为同个文件；
6.2 安装获取对应文件的md5值后，在后台中确认request的headers中的if-none-match的值是否与原来的md5值相等，若相等，则传回304，不重复传输该文件，若不同，则将文件重新传送；
6.3 ETag与缓存的不同之处在于，ETag还需要发送请求，而缓存连请求都不用发送，显然后者比较节约时间，但前者机动性较强；