---
title: 代码优化
date: 2019-07-21 21:38:33
tags:
---
### 代码优化
1. 只要是相似的代码，就存在优化的可能；
2. 封装函数封装到引用部分最简；
3. 使用命名空间：对于相关的函数装载，用**window.XXX = {} / var XXX={}**获取一个对象，然后将函数分装在XXX.xxxxx中，现在使用已经不多了，如今比较流行直接**节点.函数名(）**的调用方法；
4. 拓展node接口：通过篡改Node.prototype的属性，装载一个函数在里面，使得后面的函数调用可以直接熊proto中调用，但是和上种方法一样使用不频繁，用JQuery就可以实现；
5. 函数调用时如果括号内不填内容，就会默认this指向前面传入的元素；使用call调用时一定要在被传入数据前加元素，不能不填；
6. **内容（html）、样式（css）、行为（js）的分离；**
7. html中，img标签在图片加载出来之前会分配一个栈等待，如果后面图片先加载出来，前面的图片加载出来后就会进行重排，这样会浪费CPU，所以一般在写img的时候，如果图片宽高已知，需要给在img中提前写明；
8. 闭包的使用：当两个互不相通的立即执行函数作用域，一个需要调用另一个的内部变量，这时候就可以使用闭包的方法，在有变量的函数作用域内将变量引用到window.下的一个函数中，然后再在另外一个函数作用域内调用，这样就能实现闭包方法的变量跨域使用，但是只能访问无法操作。
9.  **MVC（Model（数据） View（视图） Controller（逻辑或其他））：**
    controller监听view，一旦view被触发，就会通知controller，调用model，model就会去请求server，server再响应model，model再返回数据给controller，controller再更新model，这就是MVC代码思想；
10. 对于函数的this，如果调用scroll等方法且使用function(){}时候，this指向的是当前滚动或点击的元素，这样就没办法操作原来的元素，解决这个问题，只需要在操作节点后面**加.bind(this)**即可。或者使用箭头函数() => {}，箭头函数内外的this不会改变，不会受到监听事件的影响。
11. IE不支持ES6的let语法，所以如果要通用必须经过转化为var，就安装**babel**，将文件复刻到lib目录中，就可以达到目的；(注意事宜见webpack相关)；

### 前端统一目录
1. src（source）：未经翻译的目录；
2. dist（distribution）：发布代码；
3. vendors：第三方代码，如jquery等；
4. node_modules：第三方包；